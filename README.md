# Materialize - Raspberry Pi Temperature Sensors Demo

This is a self-contained demo using [Materialize](https://materialize.com/) to process data directly from a PostgreSQL server. The data is generated by a Raspberry Pi temperature mock service simulating 50 devices reporting to an AdonisJS API mock service.

![mz-raspberry-pi-temperature diagram](https://user-images.githubusercontent.com/21223421/142778945-ff7d6bc2-ddc5-4a85-8074-af2944737822.png)

## Prerequisites

Before you get started, you need to make sure that you have Docker and Docker Compose installed.

You can follow the steps here on how to install Docker:

> [Installing Docker](https://materialize.com/docs/third-party/docker/)

## Overview

In this demo, we’ll look at monitoring the temperature of a set of Raspberry Pi devices and extracting some insights from them.

### Raspberry Pi Mock

The main source of data is a Raspberry Pi Mock service, that simulates 50 devices reporting their CPU temperature to a mock API service built with AdonisJS.

The mock service generates about ~25 new requests to the mock API service every second.

### API Mock service and PostgreSQL

The API mock service receives the data from the 50 simulated Raspberry Pi and stores each request in a PostgreSQL instance.

The data that is being received with each request is:

* The name of the Raspberry Pi device.
* The timestamp when the temperature was measured.
* The temperature of the device, in celsius.

The Mock API will save all data in a table called `sensors`. The columns of the `sensors` table are:

* `name`
* `timestamp`
* `temperature`

### Materialize

Materialize presents an interface to ingest the temperature data from the PostgreSQL database.

In this demo, we are going to use Materialize to:

* [Create a PostgreSQL source](https://materialize.com/docs/sql/create-source/postgres/)
* Materialize the PostgreSQL data, which will be retained all in memory.
* Provide a SQL interface to query the temperature data. We will connect to Materialize through mzcli, which is our forked version of pgcli.
* Explore the Materialize data via Metabase.

## Running the demo

Clone the repository:

```
git clone https://github.com/bobbyiliev/mz-raspberry-pi-temperature.git
```

Access the directory:

```
cd mz-raspberry-pi-temperature
```

Build the Raspberry Pi Mock images:

```
docker-compose build
```

Start all of the services:

```
docker-compose up -d
```

### Access Materialize

```
docker-compose run mzcli
```

### Create Materialize Source:

To create a PostgreSQL Materialize Source run the following statement:

```sql
CREATE MATERIALIZED SOURCE "mz_source" FROM POSTGRES
CONNECTION 'user=postgres port=5432 host=postgres dbname=postgres password=postgres'
PUBLICATION 'mz_source';
```

A quick rundown of the above statement:

* `MATERIALIZED`: Materializes the PostgreSQL source’s data. All of the data is retained in memory and makes sources directly selectable.
* `mz_source`: The name for the PostgreSQL source.
* `CONNECTION`: The PostgreSQL connection parameters.
* `PUBLICATION`: The PostgreSQL publication, containing the tables to be streamed to Materialize.



### Create a view:

Once we've created the PostgreSQL source, in order to be able to query the PostgreSQL tables, we would need to create views that represent the upstream publication’s original tables. In our case, we only have one table called `sensors` so the statement that we would need to run is:

```sql
CREATE VIEWS FROM SOURCE mz_source (sensors);
```

To see the available views run:

```sql
SHOW FULL VIEWS;
```

### Creating more materialized views

Example 1:

```sql
CREATE MATERIALIZED VIEW mz_count AS SELECT count(*) FROM sensors;
```

Querying the `mz_count` view:

```
\timing

SELECT * FROM mz_count;

// Output
 count 
-------
 34565
(1 row)

Time: 2.299 ms
```

Example 2: Average temperature of all sensors

```sql
CREATE MATERIALIZED VIEW mz_total_avg AS SELECT avg(temperature::float) FROM sensors;
```

Query the `mz_total_avg`:

```
SELECT * FROM mz_total_avg;

// Output:
        avg
-------------------
 59.02989081226408
(1 row)

Time: 2.984 ms
```

Example 3: Sort by temp average

```sql
CREATE MATERIALIZED VIEW average AS SELECT name::text, avg(temperature::float) AS temp FROM sensors GROUP BY (name);
```

Query the `average` view:

```sql
SELECT * FROM average LIMIT 10;

// Output
     name     |        temp
--------------+--------------------
 raspberry-1  |  58.60756530123859
 raspberry-2  |  58.95694631912029
 raspberry-3  | 58.628198038515066
 raspberry-4  |  59.40673999174753
 raspberry-5  | 59.079367226960734
 raspberry-6  |  58.96244838239402
 raspberry-7  |   58.4658871719401
 raspberry-8  |   58.9830811196705
 raspberry-9  | 59.398486896836936
 raspberry-10 | 59.669463513068024
(10 rows)

Time: 2.353 ms
```

## Metabase

In order to access the Metabase instance visit `http://localhost:3030` if you are running the demo locally or `http://your_server_ip:3030` if you are running the demo on a server. Then follow the steps to complete the Metabase setup.

Make sure to select Materialize as the source of the data.

Once ready you will be able to visualize your data just as you would with a standard PostgreSQL database.

![Metabase](https://user-images.githubusercontent.com/21223421/142780602-043f36c7-f279-4dc7-8853-99ddb31b452f.png)

## Stopping the demo

To stop all of the services run:

```
docker-compose down
```

## Helpful resources

* `[CREATE SOURCE: PostgreSQL](https://materialize.com/docs/sql/create-source/postgres/)`
* `[CREATE SOURCE](https://materialize.com/docs/sql/create-source/)`
* `[CREATE VIEWS](https://materialize.com/docs/sql/create-views)`
* `[SELECT](https://materialize.com/docs/sql/select)`